package thewho.repository

import doobie.implicits._
import doobie.util.Read
import doobie.util.fragment.Fragment
import doobie.util.transactor.{ Transactor => DoobieTransactor }
import scalaz.zio.interop.catz._
import scalaz.zio.{ IO, Task }
import thewho.error.{ CommonRepositoryFailure, RepositoryError, RepositoryException, RepositoryFailure }

trait syntax {

  protected def _xa: DoobieTransactor[Task]

  type UpdatedRowsCount = Int

  implicit class FragmentSyntax(fragment: Fragment) {

    /**
     * Run the sql query succeeding with an Option.
     *
     * @tparam A The type of the value returned inside the Option
     */
    def _query[A: Read]: IO[RepositoryFailure, Option[A]] =
      fragment.query[A].option.transact(_xa).mapError(CommonRepositoryFailure)

    /**
     * The same as [[_query]] but with a default value in the error channel or
     * the unwrapped result in the success channel.
     *
     * @param ifEmpty The default value for th error channel
     * @tparam A The type of the value returned in the success channel
     */
    def _queryOrErrorWith[A: Read](ifEmpty: RepositoryError): IO[RepositoryException, A] =
      _query[A] >>= fromOption(ifEmpty)

    /**
     * Run the sql query returning the number of rows affected.
     */
    def _update: IO[RepositoryFailure, UpdatedRowsCount] =
      fragment.update.run.transact(_xa).mapError(CommonRepositoryFailure)

    /**
     * The same as [[_update]] but failing with the provided error if no rows were affected.
     *
     * @param ifNoHits The error in case of no rows affected
     */
    def _updateOrErrorWith(ifNoHits: RepositoryException): IO[RepositoryException, UpdatedRowsCount] =
      _update >>= orErrorWith(ifNoHits)

    /**
     * Run the sql query returning the key of the value generated by the database.
     *
     * @tparam A The type of the generated key
     */
    def _create[A: Read]: IO[RepositoryFailure, A] =
      fragment.update.withUniqueGeneratedKeys[A]("id").transact(_xa).mapError(CommonRepositoryFailure)

  }

  private def fromOption[A](ifEmpty: RepositoryError)(option: Option[A]): IO[RepositoryError, A] =
    option.fold[IO[RepositoryError, A]](IO fail ifEmpty)(IO succeed)

  private def orErrorWith(
    ifError: RepositoryException
  )(updatedRowsCount: UpdatedRowsCount): IO[RepositoryException, UpdatedRowsCount] =
    updatedRowsCount match {
      case 0 => Task fail ifError
      case i => Task succeed i
    }

}
