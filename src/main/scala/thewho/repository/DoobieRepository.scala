package thewho.repository

import doobie._
import doobie.util.Read
import scalaz.zio.interop.catz._
import scalaz.zio.{ IO, Task }
import thewho.auth.{ Credential, CredentialId, User, UserId }
import thewho.repository.Repository.Service
import thewho.repository.error._

trait DoobieRepository extends Repository {

  protected def xa: Transactor[Task]

  override final val repository = new Service[Any] {

    import syntax._

    override final def heartBeat: IO[RepositoryFailure, Unit] = sql.heartBeat._query[Unit].map(_ => ())

    override final def createUser(credential: Credential): IO[RepositoryException, User] =
      for {
        credentialExists <- credentialExists(credential.id)
        _                <- IO.when(credentialExists)(IO fail CredentialAlreadyExist)
        userId           <- sql.user.create(credential)._create[UserId]
      } yield User(userId, credential)

    private def credentialExists(credentialId: CredentialId): IO[RepositoryException, Boolean] =
      findCredential(credentialId).map(_ => true).catchSome { case CredentialNotFound => IO succeed false }

    override final def findUser(userId: UserId): IO[RepositoryException, User] =
      for {
        credential <- findCredential(userId)
      } yield User(userId, credential)

    override final def findUser(credentialId: CredentialId): IO[RepositoryException, User] =
      for {
        credential <- findCredential(credentialId)
        userId     <- sql.user.find(credentialId)._queryOrErrorWith[UserId](UserNotFound)

      } yield User(userId, credential)

    override final def deleteUser(userId: UserId): IO[RepositoryException, UserId] =
      for {
        credential <- findCredential(userId)
        _          <- deleteCredential(credential.id)
        _          <- sql.user.delete(userId)._update
      } yield userId

    override final def createCredential(credential: Credential, userId: UserId): IO[RepositoryException, Credential] =
      sql.credential.create(credential)(userId)._updateOrErrorWith(NoCredentialsCreated).map(_ => credential)

    override final def findCredential(credentialId: CredentialId): IO[RepositoryException, Credential] =
      sql.credential.find(credentialId)._queryOrErrorWith[Credential](CredentialNotFound)

    override final def findCredential(userId: UserId): IO[RepositoryException, Credential] =
      sql.credential.find(userId)._queryOrErrorWith[Credential](CredentialNotFound)

    override final def updateCredential(credential: Credential): IO[RepositoryException, Credential] =
      sql.credential.update(credential)._updateOrErrorWith(NoCredentialsUpdated).map(_ => credential)

    override final def deleteCredential(credentialId: CredentialId): IO[RepositoryException, CredentialId] =
      sql.credential.delete(credentialId)._updateOrErrorWith(NoCredentialsUpdated).map(_ => credentialId)

  }

  object syntax {

    import doobie.implicits._

    type UpdatedRowsCount = Int

    implicit class FragmentSyntax(fragment: Fragment) {

      /**
       * Run the sql query succeeding with an Option.
       *
       * @tparam A The type of the value returned inside the Option
       */
      def _query[A: Read]: IO[RepositoryFailure, Option[A]] =
        fragment.query[A].option.transact(xa).mapError(CommonRepositoryFailure)

      /**
       * The same as [[_query]] but with a default value in the error channel or
       * the unwrapped result in the success channel.
       *
       * @param ifEmpty The default value for th error channel
       * @tparam A The type of the value returned in the success channel
       */
      def _queryOrErrorWith[A: Read](ifEmpty: RepositoryError): IO[RepositoryException, A] =
        _query[A] >>= fromOption(ifEmpty)

      /**
       * Run the sql query returning the number of rows affected.
       */
      def _update: IO[RepositoryFailure, UpdatedRowsCount] =
        fragment.update.run.transact(xa).mapError(CommonRepositoryFailure)

      /**
       * The same as [[_update]] but failing with the provided error if no rows were affected.
       *
       * @param ifNoHits The error in case of no rows affected
       */
      def _updateOrErrorWith(ifNoHits: RepositoryError): IO[RepositoryException, UpdatedRowsCount] =
        _update >>= orErrorWith(ifNoHits)

      /**
       * Run the sql query returning the key of the value generated by the database.
       *
       * @tparam A The type of the generated key
       */
      def _create[A: Read]: IO[RepositoryFailure, A] =
        fragment.update.withUniqueGeneratedKeys[A]("id").transact(xa).mapError(CommonRepositoryFailure)

    }

    private def fromOption[A](ifEmpty: RepositoryError)(option: Option[A]): IO[RepositoryError, A] =
      option.fold[IO[RepositoryError, A]](IO fail ifEmpty)(IO succeed)

    private def orErrorWith(
      ifError: RepositoryError
    )(updatedRowsCount: UpdatedRowsCount): IO[RepositoryError, UpdatedRowsCount] =
      updatedRowsCount match {
        case 0 => Task fail ifError
        case i => Task succeed i
      }

  }

  object sql {

    import doobie.implicits._

    final val heartBeat = sql"""SELECT true"""

    object user {

      final val create = sql"""INSERT INTO users DEFAULT VALUES"""

      def create(credential: Credential) =
        sql"""
             |with aux as (
             |  INSERT INTO users DEFAULT VALUES RETURNING id
             |)
             |INSERT INTO credentials (id, secret, user_id)
             |SELECT ${credential.id}, ${credential.secret}, id FROM aux RETURNING user_id
           """.stripMargin

      def find(credentialId: CredentialId) = sql"""SELECT (user_id) FROM credentials WHERE id = $credentialId"""

      def delete(userId: UserId) = sql"""DELETE FROM users WHERE id = $userId"""

    }

    object credential {

      def create(credential: Credential)(userId: UserId) =
        sql"""
             |INSERT INTO credentials (id, secret, user_id)
             |VALUES (${credential.id}, ${credential.secret}, $userId)
             |""".stripMargin

      def find(credentialId: CredentialId) =
        sql"""SELECT * FROM credentials WHERE credentials.id = $credentialId"""

      def find(userId: UserId) = sql"""SELECT * FROM credentials WHERE credentials.user_id = $userId"""

      def update(credential: Credential) =
        sql"""UPDATE credentials SET secret = ${credential.secret} WHERE id = ${credential.id}"""

      def delete(credentialId: CredentialId) = sql"""DELETE FROM credentials WHERE id = $credentialId"""

    }

  }

}
